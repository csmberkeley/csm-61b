\question
\begin{lstlisting}
public interface Consumable {
    public void consume();
}
public abstract class Food implements Consumable {
    String name;
    public abstract void prepare();
    public void play() {
        System.out.println("Mom says, 'Don't play with your food.'");
    }
}
public class Snack extends Food {
    public void prepare() {
        System.out.println("Taking " + name + " out of wrapper");
    }
    public void consume() {
        System.out.println("Snacking on " + name);
    }
}
\end{lstlisting}

\begin{parts}
\part Compare and contrast interfaces and abstract classes.
\begin{solution}[2in]
\begin{itemize}
\item Java classes cannot extend multiple superclasses (unlike Python) but classes can implement multiple interfaces.
\item Interfaces are implicitly public.
\item Interfaces can't have fields declared as instance variables; any fields that are declared are implicitly \texttt{static} and \texttt{final}.
\item Interfaces uses the \texttt{default} keyword to declare concrete implementations while abstract classes use the \texttt{abstract} keyword to declare abstract implementations.
\item Interfaces define interfaces define the way we interact with an implementing object or functions of an object. Conversely, abstract classes define an "is-a" relationship and tell us more about the object's fundamental existence.
\end{itemize}
\end{solution}

\part Do we need the \texttt{play} method in \texttt{Snack}?
\begin{solution}[0.75in]
No, we do not need the \texttt{play} method because it's already defined in the abstract class. Java will lookup the parent class's method if it cannot find it in the child class.
\end{solution}

\part \texttt{Consumable chips = new Snack();} \\
Does this compile?
\begin{solution}[0.5in]
Yes, the code compiles since \texttt{Snack} inherits from the \texttt{Food} class which implements the \texttt{Consumable} interface.
\end{solution}
\end{parts}
\begin{blocksection}
\question
\begin{lstlisting}
class Dog {
    public void walk() {
        System.out.println("The dog is walking");
    }
}
class Beagle extends Dog {
    @Override
    public void walk() {
        System.out.println("The beagle is walking");
    }
}
\end{lstlisting}

What would Java display?

\begin{parts}
\part
\begin{verbatim}
Dog fido1 = new Dog();
fido1.walk();
\end{verbatim}
\begin{solution}[0.7in]
\begin{verbatim}
The dog is walking
\end{verbatim}
\end{solution}

\part
\begin{verbatim}
Beagle fido2 = new Beagle();
fido2.walk();
\end{verbatim}
\begin{solution}[0.7in]
\begin{verbatim}
The beagle is walking
\end{verbatim}
\end{solution}

\part
\begin{verbatim}
Beagle fido3 = new Dog();
fido3.walk();
\end{verbatim}
\begin{solution}[0.7in]
Compile-time error. A container meant for \lstinline$Beagle$s can't contain \lstinline$Dog$s.
\end{solution}

\part
\begin{verbatim}
Dog fido4 = new Beagle();
fido4.walk();
\end{verbatim}
\begin{solution}[0.7in]
\begin{verbatim}
The beagle is walking
\end{verbatim}

A container for \lstinline$Dog$s can contain \lstinline$Beagle$s. At compile
time, \lstinline$fido.walk()$ is linked to \lstinline$Dog.walk()$ but at
runtime, this method is overridden by \lstinline$Beagle.walk()$.
\textbf{Meta:} It can be useful to talk about the static types of variables as boxes with labels and the dynamic type 
of an object as what you place in the box. So long as what you place in the box fits the label (i.e. a \lstinline$Beagle$ 
is a \lstinline$Dog$, so a dynamic \lstinline$Beagle$ can be placed in a static \lstinline$Dog$) then no compiler errors occur. Remember to mention dynamic method lookup.
\end{solution}
\end{parts}
\end{blocksection}

\begin{solution}

\end{solution}

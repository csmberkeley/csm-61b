\begin{blocksection}
\question Provide tight asymptotic runtime bounds in terms of $N$, the number
of nodes in the tree, for the following operations and data structures.

\ifprintanswers\else
{
\renewcommand{\arraystretch}{2}
\setlength{\tabcolsep}{16pt}
\begin{tabularx}{\textwidth}{Xp{1in}p{1in}}
Operations                         & Binary Search      & Red-Black      \\\hline
\lstinline$boolean contains(T o);$ &                    &                \\
\lstinline$void insert(T o);$      &                    &                \\
\lstinline$T get(int i);$          &                    &
\end{tabularx}
}
\fi

\begin{solution}
{
\renewcommand{\arraystretch}{2}
\setlength{\tabcolsep}{16pt}
\begin{tabularx}{\textwidth}{Xll}
Operations                         & Binary Search      & Red-Black               \\\hline
\lstinline$boolean contains(T o);$ & $\Omega(1)\; O(N)$ & $\Omega(1)\; O(\log N)$ \\
\lstinline$void insert(T o);$      & $\Omega(1)\; O(N)$ & $\Theta(\log N)$        \\
\lstinline$T get(int i);$          & $\Omega(1)\; O(N)$ & $\Omega(1)\; O(\log N)$
\end{tabularx}
}

For both \lstinline$boolean contains(T o)$ and \lstinline$get(int i)$, the logic is as follows:
The best case is always $\Omega(1)$ for both binary search trees and balanced binary search trees.  This is the case if the node we are looking for is at the root of the tree.  The worst case for binary search trees is if the tree is completely unbalanced (a spindly tree), and the node we are looking for is at the leaf of the tree.  This would have a complexity of $O(N)$, because we have to look at every node to find the one we are looking for.  However, for a balanced binary search tree, because it is balanced, we know that the height of the tree will never exceed $\log N$.  Thus, even if the node we are looking for is a leaf, we will never have to search more than $O(\log N)$ nodes.

For \lstinline$void insert(T o)$, the logic is as follows:
We always have to insert nodes at the leaf level.  For a binary search tree, imagine a right-leaning spindly tree (where all of the root's children are in its right subtree).  To insert a node in the root's left subtree, this would simply be a constant time operation because there are no nodes in the left subtree, so we would just need to set the root's left child to the node we are inserting.  This is the best case for binary search trees, so the runtime is $\Omega(1)$.  However, to insert a node in the root's right subtree, we would have to move all the way down the spindly tree, passing every node, to reach the leaf node to insert the new node.  This is the worst case for binary search trees, so the runtime is $O(N)$.  For balanced binary search trees, the height will always be $O(\log N)$ nodes.  This means that for every insertion, we will always have to go to the leaf node, which will be at most $O(\log N)$ nodes.  Thus, the overall runtime is $\Theta(\log N)$.

\end{solution}
\end{blocksection}

\question

\begin{lstlisting}
public void treeTraversal(Fringe<Node> fringe) {
    fringe.add(root);
    while (!fringe.isEmpty()) {
        Node node = fringe.remove();
        System.out.print(node.value);
        if (node.left != null) {
            fringe.add(node.left);
        }
        if (node.right != null) {
            fringe.add(node.right);
        }
    }
}
\end{lstlisting}

\marginpar{\subimport{../}{example-tree.tex}}

What would Java display?

\begin{parts}
\part \lstinline$tree.traversal(new Queue<Node>());$
\begin{solution}[0.75in]
\begin{verbatim}
1275934
\end{verbatim}

Notice that this solution goes in breadth-first order. We see that we start at
the root $1$, and then proceed to traverse the tree level-by-level. The second
level is $2$ and $7$, which are both one hop away from the root. The third
level is $5$, $9$, and $3$, which are all two hops away from the root. Lastly,
we have $4$, which is three hops away from the root.
\end{solution}

\part \lstinline$tree.traversal(new Stack<Node>());$
\begin{solution}[0.75in]
\begin{verbatim}
1734295
\end{verbatim}

Notice that this solution goes in depth-first order. We first traverse all the
way down the right branch: $1$, $7$, $3$, $4$. Once we reach $4$, the leaf
node, we go back up to the root and traverse all the way down the left branch:
$2$, $9$, $5$. We always traverse the right branch first due to the way the
code is written (the right branch is added to the stack after the left branch,
meaning the right branch would be explored first in LIFO ordering).
\end{solution}
\end{parts}
